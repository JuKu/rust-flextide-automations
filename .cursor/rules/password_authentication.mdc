---
alwaysApply: false
description: Defines password hashing, authentication, and security best practices for Rust REST backend applications. Ensures secure password storage, authentication flows, and protection against common attacks.
---

# Password Hashing & Authentication Best Practices

## Overview

This document outlines security best practices for password hashing, authentication, and related security measures in Rust REST backend applications.

## Password Hashing

### Recommended Algorithm: Argon2

**Argon2** is the current industry standard and winner of the Password Hashing Competition (2015). It's designed to be memory-hard, making it resistant to both CPU and GPU-based attacks.

**Rust Crate**: `argon2` (https://crates.io/crates/argon2)

```rust
use argon2::{
    password_hash::{rand_core::OsRng, PasswordHash, PasswordHasher, PasswordVerifier, SaltString},
    Argon2,
};

// Hashing a password
fn hash_password(password: &str) -> Result<String, argon2::password_hash::Error> {
    let salt = SaltString::generate(&mut OsRng);
    let argon2 = Argon2::default();
    let password_hash = argon2.hash_password(password.as_bytes(), &salt)?;
    Ok(password_hash.to_string())
}

// Verifying a password
fn verify_password(password: &str, hash: &str) -> Result<bool, argon2::password_hash::Error> {
    let parsed_hash = PasswordHash::new(hash)?;
    let argon2 = Argon2::default();
    Ok(argon2.verify_password(password.as_bytes(), &parsed_hash).is_ok())
}
```

### Alternative: bcrypt

If Argon2 is not available, **bcrypt** is a well-established alternative.

**Rust Crate**: `bcrypt` (https://crates.io/crates/bcrypt)

```rust
use bcrypt::{hash, verify, DEFAULT_COST};

// Hashing (cost factor 12 is recommended for 2024+)
fn hash_password(password: &str) -> Result<String, bcrypt::BcryptError> {
    hash(password, DEFAULT_COST) // or use cost 12
}

// Verifying
fn verify_password(password: &str, hash: &str) -> bool {
    verify(password, hash).unwrap_or(false)
}
```

### Key Requirements

1. **Never store passwords in plain text** - Always hash before storing
2. **Use unique salts** - Each password must have a unique, randomly generated salt
3. **Use appropriate cost factors**:
   - Argon2: Use default parameters (memory: 19456 KB, iterations: 2, parallelism: 1)
   - bcrypt: Use cost factor 12 or higher (DEFAULT_COST is 12)
4. **Store hash format**: Store the complete hash string (includes salt and parameters)
   - Argon2 format: `$argon2id$v=19$m=19456,t=2,p=1$salt$hash`
   - bcrypt format: `$2b$12$salt22chars...hash31chars`

## Password Validation

### Password Policy Requirements

Enforce strong password policies:

```rust
fn validate_password(password: &str) -> Result<(), String> {
    // Minimum length: 12 characters (recommended for 2024+)
    if password.len() < 12 {
        return Err("Password must be at least 12 characters long".to_string());
    }
    
    // Maximum length: 128 characters (prevent DoS)
    if password.len() > 128 {
        return Err("Password must be no more than 128 characters".to_string());
    }
    
    // Check for common weak passwords
    let common_passwords = ["password", "12345678", "qwerty", "admin"];
    let password_lower = password.to_lowercase();
    if common_passwords.iter().any(|&p| password_lower.contains(p)) {
        return Err("Password is too common".to_string());
    }
    
    // Optional: Require character variety (but don't be too strict)
    // Prefer length over complexity
    
    Ok(())
}
```

### Password Policy Guidelines

- **Minimum length**: 12 characters (prefer longer)
- **Maximum length**: 128 characters (prevent DoS attacks)
- **Complexity**: Encourage but don't require (length > complexity)
- **Common passwords**: Reject known weak passwords
- **User-friendly**: Don't make requirements so strict users write passwords down

## Authentication Flow

### Registration

```rust
pub async fn register(
    State(state): State<AppState>,
    Json(payload): Json<RegisterRequest>,
) -> Result<Json<Value>, (StatusCode, Json<Value>)> {
    // 1. Validate email format
    if !is_valid_email(&payload.email) {
        return Err((StatusCode::BAD_REQUEST, Json(json!({ "error": "Invalid email format" }))));
    }
    
    // 2. Validate password strength
    if let Err(e) = validate_password(&payload.password) {
        return Err((StatusCode::BAD_REQUEST, Json(json!({ "error": e }))));
    }
    
    // 3. Check if user already exists
    // ... database check ...
    
    // 4. Hash password
    let password_hash = hash_password(&payload.password)
        .map_err(|_| (StatusCode::INTERNAL_SERVER_ERROR, Json(json!({ "error": "Failed to hash password" }))))?;
    
    // 5. Store user in database
    // ... database insert with hashed password ...
    
    // 6. Generate JWT token
    // ... token generation ...
    
    Ok(Json(json!({ "token": token, "email": payload.email })))
}
```

### Login

```rust
pub async fn login(
    State(state): State<AppState>,
    Json(payload): Json<LoginRequest>,
) -> Result<Json<Value>, (StatusCode, Json<Value>)> {
    // 1. Rate limiting check (see Rate Limiting section)
    if !check_rate_limit(&payload.email).await {
        return Err((StatusCode::TOO_MANY_REQUESTS, Json(json!({ "error": "Too many login attempts" }))));
    }
    
    // 2. Find user by email
    let user = find_user_by_email(&payload.email).await?;
    
    // 3. Verify password
    if !verify_password(&payload.password, &user.password_hash) {
        // Log failed attempt
        record_failed_login(&payload.email).await;
        return Err((StatusCode::UNAUTHORIZED, Json(json!({ "error": "Invalid email or password" }))));
    }
    
    // 4. Check if account is locked
    if user.account_locked_until > Utc::now() {
        return Err((StatusCode::FORBIDDEN, Json(json!({ "error": "Account temporarily locked" }))));
    }
    
    // 5. Reset failed login attempts on successful login
    reset_failed_login_attempts(&payload.email).await;
    
    // 6. Generate JWT token
    // ... token generation ...
    
    Ok(Json(json!({ "token": token, "email": payload.email })))
}
```

## Rate Limiting

### Login Attempt Rate Limiting

Implement rate limiting to prevent brute-force attacks:

```rust
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use tokio::time::{Duration, Instant};

struct RateLimiter {
    attempts: Arc<Mutex<HashMap<String, Vec<Instant>>>>,
}

impl RateLimiter {
    fn new() -> Self {
        Self {
            attempts: Arc::new(Mutex::new(HashMap::new())),
        }
    }
    
    async fn check_rate_limit(&self, identifier: &str) -> bool {
        let mut attempts = self.attempts.lock().unwrap();
        let now = Instant::now();
        let window = Duration::from_secs(900); // 15 minutes
        
        // Clean old attempts
        let entry = attempts.entry(identifier.to_string()).or_insert_with(Vec::new);
        entry.retain(|&time| now.duration_since(time) < window);
        
        // Check limit (5 attempts per 15 minutes)
        if entry.len() >= 5 {
            return false;
        }
        
        entry.push(now);
        true
    }
}
```

### Recommended Limits

- **Login attempts**: 5 failed attempts per 15 minutes per IP/email
- **Registration**: 3 registrations per hour per IP
- **Password reset**: 3 requests per hour per email
- **General API**: Use `tower-http` rate limiting middleware

## Account Lockout

### Temporary Account Lockout

After repeated failed login attempts, temporarily lock the account:

```rust
async fn handle_failed_login(email: &str) {
    let failed_attempts = increment_failed_attempts(email).await;
    
    // Lock account after 5 failed attempts for 30 minutes
    if failed_attempts >= 5 {
        lock_account_until(email, Utc::now() + Duration::minutes(30)).await;
    }
}
```

## JWT Token Security

### Token Configuration

```rust
use jsonwebtoken::{encode, decode, Header, EncodingKey, DecodingKey, Validation, Algorithm};

// Token expiration: 24 hours for access tokens
let exp = (Utc::now() + Duration::hours(24)).timestamp() as usize;

// Use HS256 algorithm (or RS256 for better security)
let mut header = Header::default();
header.alg = Algorithm::HS256;

// Strong secret key (minimum 256 bits / 32 bytes)
// Store in environment variable, never in code
let secret = std::env::var("JWT_SECRET")
    .expect("JWT_SECRET must be set");

// Validation settings
let mut validation = Validation::default();
validation.algorithms = vec![Algorithm::HS256];
validation.validate_exp = true;
validation.validate_nbf = true;
```

### Token Best Practices

1. **Short expiration**: Access tokens should expire in 24 hours or less
2. **Refresh tokens**: Use refresh tokens for longer sessions (7-30 days)
3. **Secure storage**: Store JWT secret in environment variable, never in code
4. **Token rotation**: Consider token rotation on sensitive operations
5. **HTTPS only**: Always transmit tokens over HTTPS
6. **HttpOnly cookies**: Consider using HttpOnly cookies instead of localStorage for tokens

## Password Reset Flow

### Secure Password Reset

```rust
async fn request_password_reset(email: &str) -> Result<(), Error> {
    // 1. Find user
    let user = find_user_by_email(email).await?;
    
    // 2. Generate secure reset token (cryptographically random)
    let reset_token = generate_secure_token();
    
    // 3. Store token with expiration (15 minutes)
    store_reset_token(&user.id, &reset_token, Duration::minutes(15)).await;
    
    // 4. Send email with reset link (never include token in URL if possible)
    send_reset_email(&user.email, &reset_token).await;
    
    // 5. Rate limit: Don't reveal if email exists
    Ok(())
}

async fn reset_password(token: &str, new_password: &str) -> Result<(), Error> {
    // 1. Validate token and expiration
    let reset_record = validate_reset_token(token).await?;
    
    // 2. Validate new password strength
    validate_password(new_password)?;
    
    // 3. Hash new password
    let password_hash = hash_password(new_password)?;
    
    // 4. Update password
    update_user_password(&reset_record.user_id, &password_hash).await;
    
    // 5. Invalidate reset token
    invalidate_reset_token(token).await;
    
    // 6. Invalidate all existing sessions (force re-login)
    invalidate_user_sessions(&reset_record.user_id).await;
    
    Ok(())
}
```

## Security Headers

### Recommended Security Headers

```rust
use tower_http::set_header::SetResponseHeaderLayer;

// Add security headers middleware
.layer(SetResponseHeaderLayer::overriding(
    header::STRICT_TRANSPORT_SECURITY,
    HeaderValue::from_static("max-age=31536000; includeSubDomains"),
))
.layer(SetResponseHeaderLayer::overriding(
    header::X_CONTENT_TYPE_OPTIONS,
    HeaderValue::from_static("nosniff"),
))
.layer(SetResponseHeaderLayer::overriding(
    header::X_FRAME_OPTIONS,
    HeaderValue::from_static("DENY"),
))
.layer(SetResponseHeaderLayer::overriding(
    header::X_XSS_PROTECTION,
    HeaderValue::from_static("1; mode=block"),
))
```

## Additional Security Measures

### 1. HTTPS Only

- **Always use HTTPS** in production
- Redirect HTTP to HTTPS
- Use HSTS header (see Security Headers)

### 2. Input Validation

- Validate and sanitize all user inputs
- Use strong typing (serde validation)
- Reject suspicious patterns

### 3. Logging

- Log authentication events (success/failure)
- Don't log passwords or tokens
- Use structured logging

### 4. Error Messages

- **Never reveal** if email exists during login
- Use generic error messages: "Invalid email or password"
- Don't leak information about account status

### 5. Session Management

- Implement token blacklisting for logout
- Support token revocation
- Consider refresh token rotation

### 6. Multi-Factor Authentication (MFA)

- Support TOTP (Time-based One-Time Password)
- Support SMS/Email verification codes
- Store MFA secrets securely

## Dependencies

### Required Crates

```toml
[dependencies]
# Password hashing (choose one)
argon2 = { version = "0.5", features = ["rand_core"] }
# OR
bcrypt = "0.15"

# JWT tokens
jsonwebtoken = { version = "10.2", features = ["rust_crypto"] }

# Rate limiting
tower-http = { version = "0.6", features = ["limit"] }

# Secure random
rand = "0.8"
rand_core = { version = "0.6", features = ["std"] }
```

## Testing

### Test Password Hashing

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_password_hashing() {
        let password = "test_password_123";
        let hash = hash_password(password).unwrap();
        
        // Verify same password works
        assert!(verify_password(password, &hash).unwrap());
        
        // Verify wrong password fails
        assert!(!verify_password("wrong_password", &hash).unwrap());
        
        // Verify hash is different each time (due to salt)
        let hash2 = hash_password(password).unwrap();
        assert_ne!(hash, hash2);
    }
}
```

## References

- [OWASP Password Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)
- [Argon2 Specification](https://github.com/P-H-C/phc-winner-argon2)
- [OWASP Authentication Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html)
- [RustCrypto Password Hashing](https://github.com/RustCrypto/password-hashing)
